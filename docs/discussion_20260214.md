# プロジェクト振り返りディスカッション — 2026-02-14

---

## Q1: PPTX以外への応用可能性

**質問**: 今つくっているものはPPTX以外にも、動画作品、文書作品、といった構造物としての製作活動が必要なものには応用できる構造になっていると考えていますがあってますか？

**回答**:

概ね正しい。ただし「そのまま使える」ではなく「構造パターンが再利用できる」という意味で。

### 汎用性のある設計パターン

現在のアーキテクチャでメディア非依存な部分:

| 層 | PPTX | 動画 | 文書 |
|---|---|---|---|
| **Tier 1** (意図) | スライド構成 | シーン構成/絵コンテ | 章立て/目次 |
| **Recipe** (設計意図) | パターン・トーン・ラベル | ショット設計・演出意図 | セクション設計・強調点 |
| **Tier 2** (実装仕様) | 座標・色・フォント | タイムライン・キーフレーム | マークアップ・スタイル |
| **Template** | pptx + profile.json | モーションテンプレート | docxテンプレート/LaTeX cls |
| **Skills** | デザイン原則・診断 | 映像原則・演出手法 | 文書原則・構成手法 |
| **Assembly** | python-pptx結合 | FFmpeg/After Effects | pandoc/python-docx |

特に汎用性が高い部分:

1. **3層分離**: 「何を伝えたいか → どう見せるか → どう実装するか」は構造物制作の普遍的パターン
2. **Recipe層**: テンプレート非依存の設計意図書。同じRecipeから異なる出力形式に変換できる考え方はそのまま通用する
3. **Skills のオンデマンド読み込み**: コンテキスト制約下でAIの知識を管理する仕組みはメディア非依存
4. **対話ベースの段階的レビュー**: 一括生成ではなく1単位ずつ確認する思想

### ただし、そのままでは使えない部分

- **pptx_engine.py**: 完全にPPTX固有。動画なら別のエンジンが必要
- **座標系・オブジェクト型**: `box`, `arrow`, `left/top/width` はスライド固有
- **profile.json のスキーマ**: レイアウト・プレースホルダーの概念がPPTX前提

### 率直な評価

現状は「PPTXに特化した実装の中に、汎用的な設計思想が埋め込まれている」状態。もし本当にマルチメディア対応を目指すなら:

- 3層フローの抽象インターフェースを定義する（Tier 1/Recipe/Tier 2 の共通スキーマ）
- メディア固有の部分をプラグイン化する（engine, template, assembly をメディア別に差し替え）

ただし、今の段階でそれをやるのは過剰設計。「PPTX で動くものを作り切る → パターンが見えてから抽象化する」という順番は正しい。

---

## Q2: プロジェクトの本質 — 実験としての位置づけ

**質問**: 今回の取り組みは、これまで漠然とAIをつかって壁打ちしてコピペしながらPPTXをつくったりしてたのを、ちゃんと全ての工程を整理して、AIのコンテキスト保持、スキルという考え方、人がパワーポイントを作るときのフローの分解、マルチエージェントでの運用、GITHUBをつかった管理、システム開発や映像作品をはじめとした大規模な構造的創作活動における分業のノウハウ、またそれらのAI活用のノウハウといった様々なものを盛り込んで、どういうものが必要だったのかを実験的に作っていっているという認識。これについて考察してほしい。

**回答**:

その認識は正確であり、かつこのプロジェクトの最も重要な価値がそこにある。

### 「ツール」ではなく「実験」であることの意味

このプロジェクトの本質は「PowerPoint自動生成ツール」ではない。それは実験の**題材**にすぎない。

本当にやっていることは、**「AIと人間が構造的な創作物を協働で作るとき、何が必要か」を実地に解き明かす作業**。PPTXはたまたま以下の条件を満たす良い題材だった:

- 構造がある（スライド順序、レイアウト、テンプレート）
- 創造性がある（メッセージ設計、ビジュアル表現）
- 品質判断が必要（デザイン原則、情報密度）
- 1人で完結しがち（だからこそ分業の余地が見えにくい）

### このプロジェクトで発見・言語化されたもの

振り返ると、以下のような「暗黙知」が実装を通じて形式知化されている:

**1. 意図と実装の分離が必須**

「何を伝えたいか」と「どう実装するか」を分けないとAIは座標やフォントサイズの話に引きずられる。Recipe層の発見はまさにこれ。人間のデザイナーが頭の中で無意識にやっている「設計意図の言語化」をJSON形式で強制した。

**2. AIのコンテキストは「無限の知識」ではなく「有限のワーキングメモリ」**

Skills アーキテクチャが生まれた背景。全部を一度に読み込むとコンテキストが枯渇する。必要な時に必要な知識だけ読む。これは人間のプロが「マニュアルを全部暗記せず、必要な時にリファレンスを引く」のと同じ構造。

**3. 人間の制作プロセスには暗黙の段階がある**

PPTXを作る人は無意識に「構成を考える → 各スライドの意図を決める → レイアウトする → 調整する」という段階を踏んでいる。これを明示的な Tier 1 → Recipe → Tier 2 → Assembly → Review に分解したことで、初めてAIが各段階に参加できるようになった。

**4. 分業には「共通言語」が必要**

人間同士の分業でも、映像制作なら絵コンテ、建築なら設計図がある。AIとの分業でも同じで、それがJSON形式のRecipeやoutline。テンプレートの「二重定義」（profile.json + design_guide.md）も、機械とAIという異なるエージェントへの共通言語。

**5. レビューのタイミングと粒度が品質を決める**

「一括生成して最後に確認」ではなく「1枚ずつ対話しながら作る」という方針。これはソフトウェア開発でのPRレビューや、映像制作での日次ラッシュチェックと同じ原理。手戻りのコストが段階ごとに指数関数的に増えるから、早い段階で確認する。

### もっと大きな文脈で見ると

このプロジェクトが実験しているのは、究極的には**「AIネイティブな制作パイプライン」の原型**。

従来の制作パイプライン（映像・ソフトウェア・出版）は人間同士の分業を前提に設計されている。AIが参加するとき、既存のパイプラインにAIを「はめ込む」のではなく、**AIの特性（コンテキスト制約、確率的出力、高速だが不安定）を前提にパイプラインを再設計する**必要がある。

このプロジェクトで得られた知見:

- **コンテキスト管理**: Skills、段階的読み込み、`/compact`
- **品質制御**: 対話ベースのレビュー、診断ルーブリック、サムネイル確認
- **再現性**: JSON中間形式、git管理、テンプレート分離
- **柔軟性**: Recipe層によるテンプレート非依存化

これらは「PPTXの作り方」ではなく「AIと人間が構造的創作物を作るための原則」。

---

## Q3: 自己改善サイクルへの発展

**質問**: 究極的にはこれが自己改善サイクルになっていれば非常に高度な構造物がAIだけでも構築できるようになると思っている。そのために何が必要なのかはまだぼんやりだが、この実験の延長線上にある気がする。これについてどう思うか？

**回答**:

直感は正しい。そして今のシステムには既にその断片が存在している。

### 現在のシステムに既にあるもの

自己改善サイクルに必要な4要素:

| 要素 | 必要なこと | 現状 |
|---|---|---|
| **生成** | 構造物を作る | Tier 1→Recipe→Tier 2→PPTX |
| **評価** | 出力を判定する | critique_rubric.md、サムネイル診断 |
| **修正** | 問題を直す | Tier 2 Edit → 再結合 |
| **学習** | 次に活かす | knowhow.md、MEMORY.md、Skills更新 |

4つとも存在する。ただし全て人間がトリガーを引いている。ループが自動で回っていない。

### 「自律的に回る」ために足りないもの

**1. 評価の自動化と構造化**

今の診断は「人間がサムネイルを見て、AIに聞く」形式。自己改善には、AIが自分の出力を構造的に評価し、機械可読形式で出力する必要がある。critique_rubric.md は評価基準を持っているが、評価結果のフォーマットが定義されていない。

```
（今）  人間: 「このスライド見て」 → AI: 「情報密度が高すぎます」
（必要）AI生成 → AI評価: {"score": 0.6, "issues": [...]} → AI修正
```

**2. 修正戦略の体系化**

「問題を見つけた」から「どう直すか」への変換ロジック。今は暗黙的にAIが判断しているが、パターン化が必要。「情報密度が高い → 分割 or 箇条書き削減 or 図解化」のような修正戦略マップ。

**3. 停止条件の定義**

自己改善ループには「いつ止めるか」が必要。無限ループや改悪を防ぐため、人間の美的判断を何らかの形で目的関数にエンコードする必要がある。

### 核心: 評価の2層構造

自己改善の本当の難しさは「評価」にある。生成と修正は既にできている。

- **形式的品質**: 情報密度、フォントサイズ、配置バランス、コントラスト比 → ルール化可能。今すぐ自動化できる
- **意味的品質**: メッセージは伝わるか、ストーリーは響くか、聴衆の心は動くか → ルール化が極めて困難。人間の判断が必要

今のプロジェクトで面白いのは、この2層を既に分離し始めていること。critique_rubric.md は形式的品質を、Recipe のディスカッションは意味的品質を扱っている。

### 延長線上にある現実的な姿

```
人間: 意図を伝える（Tier 1 + Recipe ディスカッション）
  ↓
AI: 生成 → 自己評価（形式的品質） → 自動修正 → 再評価
  ↓  ← このループはAIだけで回る
AI: 「形式的に最適化した結果です」
  ↓
人間: 意味的判断（「もっと危機感を出して」「この順番じゃない」）
  ↓
AI: 修正 → 自己評価ループ再実行
```

形式的品質のループはAI自律、意味的品質のループは人間参加。完全自律ではないが、人間は「形式チェック」から解放され「意味の判断」だけに集中できる。

### この実験の延長線上にあるか

**ある**。理由:

- 既に評価基準（critique_rubric.md）が外部ファイルとして存在 → 自動評価の入力になりうる
- Recipe層で「設計意図」が明示されている → 評価の「正解」として使える（意図が実現されているかを検証できる）
- 中間形式（JSON）が全段階にある → プログラム的な検証が可能

足りないのは「評価結果の構造化」「修正戦略のパターン化」「ループの自動実行」。次の実験フェーズとして自然な方向性。

---

## Q4: 模倣・守破離の不在

**質問**: 人間の創作活動においては巨人の肩に乗る、守破離、模倣によるステップが不可欠。それがここには実装されていない。ただやろうと思えばできそうな気もする。これについてはどう思うか？

**回答**:

非常に鋭い指摘。最も重要な欠落かもしれない。

### 人間の創作における模倣の役割

1. **守**: 良い手本をそのまま真似る（「この提案書のレイアウトを真似して」）
2. **破**: 手本のパターンを理解した上で、文脈に合わせて崩す
3. **離**: 手本なしに独自のパターンを生み出す

現在のシステムは、いきなり「離」をやらせている。Recipeでパターンを選び、Tier 2で座標を決めるとき、参照しているのは抽象的な原則（design_principles.md）とパターンカタログ（slide_recipe.md）だけ。具体的な手本がない。

### 今のシステムに何があって、何がないか

```
あるもの:
  テンプレート     → 「形式」の模倣（レイアウト枠、色）
  パターンカタログ → 「型」の抽象的定義（three_column, comparison等）
  デザイン原則     → 「なぜそうすべきか」の理論

ないもの:
  参照作品ライブラリ → 「この実物のように」という具体的手本
  パターン抽出      → 良い作品からパターンを学ぶプロセス
  模倣→昇華のフロー → 手本から始めて独自に発展させるワークフロー
```

### 実装できるか — できる

現在のアーキテクチャには模倣を組み込む受け皿が既にある。

**1. 参照作品の分析・登録**

template_analyzer.py が構造を抽出するように、「優れたスライド」を分析してRecipe形式で記録する。

```
python analyze_reference.py "excellent_deck.pptx"
→ refs/excellent_deck/
    ├── analysis.json              # 各スライドの構成・パターン・配色分析
    ├── 03_content.recipe.json     # 逆算されたレシピ
    └── thumbnails/                # 視覚的参照
```

template_analyzer.py の発展形。テンプレート（形式）だけでなく、コンテンツ（内容の見せ方）を分析する。

**2. Recipe生成時の参照引用**

```
今:   「3つの課題を並べたい」→ パターンカタログから three_column を選択（抽象的）
将来: 「3つの課題を並べたい」→ 参照ライブラリから類似スライドを検索
     → 「この参照作品のSlide 5が近いです」と具体例を提示
     → 「これをベースに、ここを変えよう」とディスカッション（具体的）
```

**3. 守破離の明示的ステージ**

Recipeに `reference` フィールドを追加:

```json
{
  "pattern": "three_column",
  "reference": {
    "source": "refs/award_winning_deck/05_content",
    "adaptation": "配色をクライアントカラーに変更、ラベルを課題に特化"
  }
}
```

「何を参照して、何を変えたか」が記録される。守→破の可視化。

### なぜ模倣が重要か

模倣がないと、毎回ゼロから「発明」している。これは非効率なだけでなく、品質の上限も制約する。

人間のデザイナーは頭の中に「これまで見てきた良い作品」の膨大なライブラリがある。AIにはそれがない（学習データにはあるが、特定の文脈で引き出せない）。参照ライブラリはAIに「目利きの記憶」を与えることに等しい。

### 自己改善サイクルとの接続

模倣のプロセスはQ3の自己改善サイクルと接続する:

```
生成 → 評価 → 修正 → 完成
                        ↓
              良い成果物を参照ライブラリに登録
                        ↓
              次の生成時に参照として活用（守）
                        ↓
              パターンカタログの拡充（破→離）
```

自己改善サイクルの「学習」ステップが、模倣ライブラリの蓄積として具体化される。システムは使うほど「目が肥える」。

### 現在のアーキテクチャで実装可能か

可能。理由:
- Recipe形式が「設計意図の言語」として機能 → 参照作品もRecipe形式で保存できる
- template_analyzer.py が構造抽出の前例 → コンテンツ分析への拡張は自然
- Skills のオンデマンド読み込みが動いている → 参照ライブラリも必要時に読み込める

最小限の開始方法: 手動で「良いスライドのRecipe逆算」を数例やってみて、参照→模倣のフローが有効かどうかを検証してから仕組み化する。

---

## Q5: GitHub中心のオープンコラボレーション

**質問**: 現在のシステムはVSCodeにGitHubとClaude Codeをつないで実行しているが、本来はGitHubを中心に、どんなプラットフォームでも、AIでも、参加してコラボレーションできる状況になる必要がある。何が足りなくて、どうなっていれば人もAIも参加して作業できるのか？

**回答**:

### 現在の問題: 「対話」であって「協業」ではない

```
┌─────────────────────────────┐
│  VSCode (1人のPC)            │
│  ┌───────┐    ┌───────────┐ │
│  │ 人間  │←→│ Claude Code│ │────→ GitHub (保存庫)
│  └───────┘    └───────────┘ │
└─────────────────────────────┘
```

問題点:
- 全てが1つのチャットセッションの中で起きている。外部からの参加入口がない
- GitHubは保存庫でしかない。Issues, PR, Actions, Review を使っていない
- CLAUDE.mdは「Claude Code専用の指示書」。他のAIや人間の作業手順書ではない
- ワークフローの状態が外部から見えない

### 5つの欠落

**1. 作業の「単位」と「状態」の公開**

状態がチャット履歴に埋もれている。GitHub Issues で可視化すれば誰でも進捗が分かる。

**2. 入出力の契約（JSON Schema）**

JSON形式がCLAUDE.mdに自然言語で記述されている。JSON Schema があれば任意のAIが仕様に従って出力でき、GitHub Actions でバリデーションも自動実行できる。

**3. レビュー・承認のプロトコル**

「チャットでOK」が承認。Pull Requestベースにすれば、レビューアーは人間でもAIでも良い。

**4. 自動化パイプライン（GitHub Actions）**

Tier 2ファイルがpushされたら自動で結合・サムネイル生成・品質チェック。手動CLI実行を自動化。

**5. エージェント非依存のワークフロー定義**

CLAUDE.md → WORKFLOW.md へ。特定AIに依存しない、誰でも読めるプロセス定義。

### 理想の姿

```
                    ┌──────────┐
                    │  GitHub  │ ← 中央ハブ
                    │ Issues   │ ← 作業の状態管理
                    │ PRs      │ ← レビュー・承認
                    │ Actions  │ ← 自動化
                    │ Schemas  │ ← 入出力契約
                    └──┬───────┘
           ┌───────────┼───────────┐
           ↓           ↓           ↓
     ┌──────────┐ ┌──────────┐ ┌──────────┐
     │ 参加者A  │ │ 参加者B  │ │ 参加者C  │
     │ 人間     │ │ Claude   │ │ GPT/他AI │
     │ VSCode   │ │ Code     │ │ API経由  │
     └──────────┘ └──────────┘ └──────────┘
```

各参加者は: Issue取得 → Schema準拠で成果物生成 → PR提出 → レビュー → 承認

### 現実的な優先順位

| 優先度 | 施策 | 効果 |
|---|---|---|
| **高** | JSON Schema定義 | 他の参加者が正しい形式で出力できる |
| **高** | WORKFLOW.md作成 | 特定AIに依存しないプロセス定義 |
| **中** | GitHub Issues活用 | 作業状態の可視化 |
| **中** | GitHub Actions（バリデーション） | 自動検証 |
| **低** | PR ベースのレビューフロー | 本格的な分業 |

### 率直な評価

今のシステムは「優秀なアシスタントと1対1で仕事する」モデル。価値はあるがスケールしない。GitHub中心モデルへの移行は「プロジェクト管理」の複雑さとトレードオフ。1人+1AIで十分な規模なら今の方が効率的な場合もある。JSON Schema整備とWORKFLOW.md作成から始めるのが現実的。

---

## Q6: 別のAIが同じ視点で段階的に開発を進めるには

**質問**: Q1からの議論でClaude Codeが文脈と生成物を理解した上でディスカッションしているが、全く別のAIがGitHubを参照して同じ視点になり、理想の仕組みをフェーズを切って段階的に開発を進めていくにはどうすればいいか？

**回答**:

### 問題の本質: 暗黙の文脈が移転できない

Claude Code（現セッション）が持っている知識:
- コードを書いた経験 → 「なぜこうなっているか」を知っている
- ユーザーとの対話履歴 → 設計判断の背景を知っている
- Q1-Q5のディスカッション → ビジョンを共有している
- 失敗と修正の経験 → 「何が地雷か」を知っている

この知識の大半はチャットセッションの中にしかない。別のAIには渡せない。

### 知識の所在と外部アクセス可能性

| 知識の種類 | 現在の置き場所 | 外部アクセス |
|---|---|---|
| コードの動作 | ソースコード | 可能 |
| 使い方 | CLAUDE.md | 部分的（Claude Code専用）|
| 技術的注意点 | knowhow.md | 可能 |
| 設計思想・ビジョン | この会話 | **不可能** |
| 「なぜこう作ったか」 | この会話 / git log | ほぼ不可能 |
| 今後の方向性 | この会話（Q1-Q5）| **不可能** |

### 必要な3層ドキュメント

**Layer 1: WHY（なぜ作っているか）**
- `docs/vision.md` — Q1-Q5の結論から再構成
- `docs/discussion_*.md` — ディスカッション記録
- `docs/adr/` — Architecture Decision Records（判断の理由）

**Layer 2: WHAT（何をどう作るか）**
- `docs/WORKFLOW.md` — エージェント非依存のプロセス定義
- `docs/ROADMAP.md` — フェーズ分けされた開発計画
- `CONTRIBUTING.md` — 参加方法（人間向け・AI向け）
- `schemas/` — JSON Schema（全形式）

**Layer 3: HOW（具体的にどう動かすか）**
- `README.md` — セットアップ・基本操作
- `CLAUDE.md` — Claude Code固有の指示
- `docs/knowhow.md` — 技術的注意点

### AI向けオンボーディング順序

```
1. docs/vision.md       — 何を目指しているか
2. docs/ROADMAP.md      — 現在のフェーズと次の目標
3. docs/WORKFLOW.md     — 制作フローの全体像
4. schemas/             — 各段階のデータ形式
5. docs/adr/            — 主要な設計判断とその理由
```

### フェーズ分けされた開発計画

**Phase 0: 知識の外部化（今すぐ）**
- docs/vision.md を今日のディスカッションから再構成
- README.md を整備
- ADR を主要判断について3-5本作成
- 成果: 別のAIが「なぜ」を理解できる状態

**Phase 1: 契約の定義**
- JSON Schema を全形式で定義
- WORKFLOW.md をエージェント非依存で記述
- CONTRIBUTING.md を作成
- 成果: 別のAIが「何を出力すべきか」分かる状態

**Phase 2: 自動化基盤（GitHub Actions）**
- スキーマバリデーション
- 自動Assembly + サムネイル生成
- 品質チェック（形式的品質のみ）
- 成果: PRを出せば自動で検証される状態

**Phase 3: 参照ライブラリ（模倣の基盤）**
- 参照作品の分析・登録フロー
- Recipe への reference フィールド追加
- パターンカタログの拡充
- 成果: 「手本を見て作る」が可能な状態

**Phase 4: 自己改善ループ**
- 構造化された評価出力
- 修正戦略マップ
- 自動評価→修正ループ
- 成果: 形式的品質がAI自律で改善される状態

### 最も重要なこと

Phase 0が全ての前提条件。今日のディスカッション内容が `docs/vision.md` に構造化されて残っていなければ、Phase 1以降は「手段の整備」にしかならない。今日の会話を適切にドキュメント化することが、別のAIが参加できるようになる第一歩。

---

## Q7: 実行計画の立て方 — メタ的な自己実践

**質問**: ディスカッションを踏まえて実行計画を立ててほしい。ただしコンテキスト容量を意識して、適切にスキル分解しながら組み立てないと、あなた自身がコンテキスト保持できずに正しい実行計画を作りきれない。まずどうやるか？

**回答**:

まさに自分自身のコンテキスト管理が試されている。

### アプローチ: 3層の計画プロセス

1. Q1-Q6の結論を1ページに圧縮 → `docs/vision.md`（Phase 0の最初の成果物にもなる）
2. vision.md を参照しながらフェーズ分け → `docs/ROADMAP.md`
3. 各フェーズの詳細は、そのフェーズに着手するときに展開する（今全部書かない）

「計画の計画」を先にやり、詳細は段階的に。3層アーキテクチャと同じ原理を計画立案にも適用。

### 実行結果

- `docs/vision.md` — Q1-Q6の結論を約100行に圧縮。5つの原則、4つの発展方向、5フェーズの概要
- `docs/ROADMAP.md` — Phase 0-4の詳細計画。成果物一覧、完了条件、依存関係を定義

これ自体が Phase 0 の最初の3成果物（vision.md, ROADMAP.md, discussion記録）となった。

---

## Q8: トークン上限とセッション継続性の問題

**質問**: AIとの協業で常に怖いのはAI提供会社側のトークン上限による利用停止。このままつづけたいが、あとどのくらいできるか見えていない。この問題をどう考えるか？

**回答**:

### 現実

AI側も正確な残量は見えていない。分かっていること:
- コンテキストウィンドウが埋まると自動圧縮される（既に今セッションで発生）
- API利用量の上限はAI側からは不可視
- 前回の教訓: 番号フォルダ移行が途中で切れ、中途半端なコードがリポジトリに残った

### 対策 — 今日のディスカッション自体が回答を含んでいる

**1. 作業単位を小さくして、完了ごとに保存する（原則5の実践）**
- vision.md, ROADMAP.md, discussion記録 — 全てコミット済み
- セッションが切れても成果は失われない

**2. 次のセッションが引き継げる状態を常に維持する（Q6の実践）**
- vision.md → 「何を目指しているか」
- ROADMAP.md → 「次に何をすべきか」
- MEMORY.md → Claude Codeの環境理解

**3. やり残しは未完成ではなく「次のタスク」にする**
- Phase 0の残り（README, ADR）は独立タスク。今やらなくても価値が毀損しない

### メタ的な洞察

トークン上限の問題は、実はこのプロジェクトの中核課題と同構造:
- **Q2で議論した「AIのコンテキストは有限のワーキングメモリ」** → セッション内の制約
- **Q6で議論した「暗黙の文脈が移転できない」** → セッション間の制約
- **Q5で議論した「GitHubを中央ハブに」** → セッション非依存の設計

つまり「トークンが切れても大丈夫な設計」は、「別のAIが参加できる設計」と同じ。Phase 0-1の成果物（vision.md, ROADMAP.md, Schema, WORKFLOW.md）が整備されれば、トークン上限はリスクではなく「セッション境界」として設計に組み込める。

### 今後のセッション運用ルール（提案）

1. セッション開始時に `docs/ROADMAP.md` と `docs/vision.md` を確認
2. 作業は「1コミットで完結する単位」に分解
3. 大きな意思決定やディスカッションは `docs/discussion_YYYYMMDD.md` に即時記録
4. セッション終了前に MEMORY.md を更新
5. 途中で切れても「次のタスク」が明確な状態を維持する

---
